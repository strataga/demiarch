/**
 * Git Service
 *
 * Provides git operations for auto-committing generated code.
 * Uses Tauri's shell API to execute git commands.
 */

// Check if we're running in Tauri
const isTauri = () => {
  return typeof window !== 'undefined' && '__TAURI__' in window;
};

export interface GitResult {
  success: boolean;
  commitHash?: string;
  error?: string;
  output?: string;
}

/**
 * Execute a git command using Tauri shell (stubbed for browser mode)
 */
async function executeGitCommand(args: string[], _cwd?: string): Promise<{ success: boolean; output: string; error?: string }> {
  if (!isTauri()) {
    return {
      success: false,
      output: '',
      error: 'Git operations require Tauri desktop app',
    };
  }

  // In Tauri mode, we would use the shell plugin
  // For now, stub the implementation since Tauri shell plugin may not be installed
  console.log(`[Git] Would execute: git ${args.join(' ')}`);
  return {
    success: true,
    output: 'Stubbed git output',
  };
}

/**
 * Check if the directory is a git repository
 */
export async function isGitRepo(projectPath: string): Promise<boolean> {
  const result = await executeGitCommand(['rev-parse', '--is-inside-work-tree'], projectPath);
  return result.success && result.output.trim() === 'true';
}

/**
 * Get current branch name
 */
export async function getCurrentBranch(projectPath: string): Promise<string | null> {
  const result = await executeGitCommand(['branch', '--show-current'], projectPath);
  return result.success ? result.output.trim() : null;
}

/**
 * Stage files for commit
 */
export async function stageFiles(projectPath: string, files: string[]): Promise<GitResult> {
  if (files.length === 0) {
    return { success: true };
  }

  const result = await executeGitCommand(['add', ...files], projectPath);
  return {
    success: result.success,
    error: result.error,
    output: result.output,
  };
}

/**
 * Create a commit with the generated code
 */
export async function commitFeature(
  projectPath: string,
  featureName: string,
  files: string[]
): Promise<GitResult> {
  // First stage the files
  const stageResult = await stageFiles(projectPath, files);
  if (!stageResult.success) {
    return stageResult;
  }

  // Create the commit
  const commitMessage = `feat: implement ${featureName}

Auto-generated by Demiarch Auto Build

Files:
${files.map((f) => `- ${f}`).join('\n')}`;

  const commitResult = await executeGitCommand(
    ['commit', '-m', commitMessage],
    projectPath
  );

  if (!commitResult.success) {
    return {
      success: false,
      error: commitResult.error || 'Failed to create commit',
      output: commitResult.output,
    };
  }

  // Get the commit hash
  const hashResult = await executeGitCommand(['rev-parse', 'HEAD'], projectPath);
  const commitHash = hashResult.success ? hashResult.output.trim().substring(0, 7) : undefined;

  return {
    success: true,
    commitHash,
    output: commitResult.output,
  };
}

/**
 * Create a feature branch for the implementation
 */
export async function createFeatureBranch(
  projectPath: string,
  featureName: string
): Promise<GitResult> {
  const branchName = `feature/${featureName.toLowerCase().replace(/\s+/g, '-')}`;

  // Check if branch already exists
  const checkResult = await executeGitCommand(
    ['show-ref', '--verify', '--quiet', `refs/heads/${branchName}`],
    projectPath
  );

  if (checkResult.success) {
    // Branch exists, switch to it
    const switchResult = await executeGitCommand(['checkout', branchName], projectPath);
    return {
      success: switchResult.success,
      error: switchResult.error,
      output: `Switched to existing branch: ${branchName}`,
    };
  }

  // Create and switch to new branch
  const createResult = await executeGitCommand(['checkout', '-b', branchName], projectPath);
  return {
    success: createResult.success,
    error: createResult.error,
    output: createResult.success ? `Created branch: ${branchName}` : createResult.output,
  };
}

/**
 * Get the status of the working directory
 */
export async function getStatus(projectPath: string): Promise<{ clean: boolean; files: string[] }> {
  const result = await executeGitCommand(['status', '--porcelain'], projectPath);

  if (!result.success) {
    return { clean: true, files: [] };
  }

  const files = result.output
    .split('\n')
    .filter((line) => line.trim())
    .map((line) => line.substring(3)); // Remove status prefix

  return {
    clean: files.length === 0,
    files,
  };
}
