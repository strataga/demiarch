//! User edit detection for generated code
//!
//! Tracks files generated by the system and detects when users manually
//! modify them. This is critical for:
//! - Preventing accidental overwrites of user customizations
//! - Enabling smart merge/conflict resolution
//! - Providing visibility into what has been manually changed

use crate::error::{Error, Result};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use sqlx::SqlitePool;
use std::path::Path;
use tracing::{debug, info, warn};
use uuid::Uuid;

/// Type alias for tracked file database row
type TrackedFileRow = (
    String,            // id
    String,            // project_id
    Option<String>,    // feature_id
    String,            // file_path
    String,            // content_hash
    DateTime<Utc>,     // generation_timestamp
    Option<String>,    // last_verified_hash
    Option<DateTime<Utc>>, // last_verified_at
    i32,               // edit_detected
);

/// A tracked generated file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TrackedFile {
    /// Unique identifier
    pub id: Uuid,

    /// Project this file belongs to
    pub project_id: Uuid,

    /// Optional feature that generated this file
    pub feature_id: Option<Uuid>,

    /// Relative file path from project root
    pub file_path: String,

    /// SHA-256 hash of content when generated
    pub content_hash: String,

    /// When the file was generated
    pub generation_timestamp: DateTime<Utc>,

    /// Hash when last verified (may differ from content_hash if edited)
    pub last_verified_hash: Option<String>,

    /// When the file was last verified
    pub last_verified_at: Option<DateTime<Utc>>,

    /// Whether a user edit has been detected
    pub edit_detected: bool,
}

impl TrackedFile {
    /// Create a new tracked file entry
    pub fn new(
        project_id: Uuid,
        feature_id: Option<Uuid>,
        file_path: String,
        content_hash: String,
    ) -> Self {
        Self {
            id: Uuid::new_v4(),
            project_id,
            feature_id,
            file_path,
            content_hash,
            generation_timestamp: Utc::now(),
            last_verified_hash: None,
            last_verified_at: None,
            edit_detected: false,
        }
    }
}

/// Result of checking a file for edits
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditCheckResult {
    /// The tracked file path
    pub file_path: String,

    /// Whether the file exists on disk
    pub file_exists: bool,

    /// Whether an edit was detected
    pub edit_detected: bool,

    /// Original hash when generated
    pub original_hash: String,

    /// Current hash on disk (None if file doesn't exist)
    pub current_hash: Option<String>,
}

impl EditCheckResult {
    /// Returns true if the file was modified by the user
    pub fn is_modified(&self) -> bool {
        self.edit_detected
    }

    /// Returns true if the file was deleted
    pub fn is_deleted(&self) -> bool {
        !self.file_exists
    }

    /// Returns true if the file is unchanged from generation
    pub fn is_unchanged(&self) -> bool {
        self.file_exists && !self.edit_detected
    }
}

/// Summary of edit detection across multiple files
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct EditDetectionSummary {
    /// Total files checked
    pub total_files: usize,

    /// Files that have been modified by user
    pub modified_files: Vec<String>,

    /// Files that have been deleted
    pub deleted_files: Vec<String>,

    /// Files that are unchanged
    pub unchanged_files: Vec<String>,
}

impl EditDetectionSummary {
    /// Returns true if any files have been modified or deleted
    pub fn has_changes(&self) -> bool {
        !self.modified_files.is_empty() || !self.deleted_files.is_empty()
    }

    /// Human-readable summary message
    pub fn summary(&self) -> String {
        format!(
            "Checked {} files: {} modified, {} deleted, {} unchanged",
            self.total_files,
            self.modified_files.len(),
            self.deleted_files.len(),
            self.unchanged_files.len()
        )
    }
}

/// Repository for tracking generated files
pub struct TrackedFileRepository {
    pool: SqlitePool,
}

impl TrackedFileRepository {
    /// Create a new repository
    pub fn new(pool: SqlitePool) -> Self {
        Self { pool }
    }

    /// Get a reference to the underlying pool
    pub fn pool(&self) -> &SqlitePool {
        &self.pool
    }

    /// Track a newly generated file
    pub async fn track_file(&self, file: &TrackedFile) -> Result<()> {
        sqlx::query(
            r#"
            INSERT INTO generated_files (
                id, project_id, feature_id, file_path, content_hash,
                generation_timestamp, last_verified_hash, last_verified_at, edit_detected
            )
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ON CONFLICT(project_id, file_path) DO UPDATE SET
                feature_id = excluded.feature_id,
                content_hash = excluded.content_hash,
                generation_timestamp = excluded.generation_timestamp,
                last_verified_hash = NULL,
                last_verified_at = NULL,
                edit_detected = 0
            "#,
        )
        .bind(file.id.to_string())
        .bind(file.project_id.to_string())
        .bind(file.feature_id.map(|id| id.to_string()))
        .bind(&file.file_path)
        .bind(&file.content_hash)
        .bind(file.generation_timestamp)
        .bind(&file.last_verified_hash)
        .bind(file.last_verified_at)
        .bind(file.edit_detected)
        .execute(&self.pool)
        .await
        .map_err(|e| Error::Other(format!("Database error: {}", e)))?;

        Ok(())
    }

    /// Get a tracked file by project and path
    pub async fn get_by_path(
        &self,
        project_id: Uuid,
        file_path: &str,
    ) -> Result<Option<TrackedFile>> {
        let row: Option<TrackedFileRow> = sqlx::query_as(
            r#"
            SELECT id, project_id, feature_id, file_path, content_hash,
                   generation_timestamp, last_verified_hash, last_verified_at, edit_detected
            FROM generated_files
            WHERE project_id = ? AND file_path = ?
            "#,
        )
        .bind(project_id.to_string())
        .bind(file_path)
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| Error::Other(format!("Database error: {}", e)))?;

        Ok(row.map(|r| TrackedFile {
            id: Uuid::parse_str(&r.0).unwrap_or_default(),
            project_id: Uuid::parse_str(&r.1).unwrap_or_default(),
            feature_id: r.2.as_ref().and_then(|s| Uuid::parse_str(s).ok()),
            file_path: r.3,
            content_hash: r.4,
            generation_timestamp: r.5,
            last_verified_hash: r.6,
            last_verified_at: r.7,
            edit_detected: r.8 != 0,
        }))
    }

    /// Get all tracked files for a project
    pub async fn list_by_project(&self, project_id: Uuid) -> Result<Vec<TrackedFile>> {
        let rows: Vec<TrackedFileRow> = sqlx::query_as(
            r#"
            SELECT id, project_id, feature_id, file_path, content_hash,
                   generation_timestamp, last_verified_hash, last_verified_at, edit_detected
            FROM generated_files
            WHERE project_id = ?
            ORDER BY file_path ASC
            "#,
        )
        .bind(project_id.to_string())
        .fetch_all(&self.pool)
        .await
        .map_err(|e| Error::Other(format!("Database error: {}", e)))?;

        Ok(rows
            .into_iter()
            .map(|r| TrackedFile {
                id: Uuid::parse_str(&r.0).unwrap_or_default(),
                project_id: Uuid::parse_str(&r.1).unwrap_or_default(),
                feature_id: r.2.as_ref().and_then(|s| Uuid::parse_str(s).ok()),
                file_path: r.3,
                content_hash: r.4,
                generation_timestamp: r.5,
                last_verified_hash: r.6,
                last_verified_at: r.7,
                edit_detected: r.8 != 0,
            })
            .collect())
    }

    /// Get all tracked files for a feature
    pub async fn list_by_feature(&self, feature_id: Uuid) -> Result<Vec<TrackedFile>> {
        let rows: Vec<TrackedFileRow> = sqlx::query_as(
            r#"
            SELECT id, project_id, feature_id, file_path, content_hash,
                   generation_timestamp, last_verified_hash, last_verified_at, edit_detected
            FROM generated_files
            WHERE feature_id = ?
            ORDER BY file_path ASC
            "#,
        )
        .bind(feature_id.to_string())
        .fetch_all(&self.pool)
        .await
        .map_err(|e| Error::Other(format!("Database error: {}", e)))?;

        Ok(rows
            .into_iter()
            .map(|r| TrackedFile {
                id: Uuid::parse_str(&r.0).unwrap_or_default(),
                project_id: Uuid::parse_str(&r.1).unwrap_or_default(),
                feature_id: r.2.as_ref().and_then(|s| Uuid::parse_str(s).ok()),
                file_path: r.3,
                content_hash: r.4,
                generation_timestamp: r.5,
                last_verified_hash: r.6,
                last_verified_at: r.7,
                edit_detected: r.8 != 0,
            })
            .collect())
    }

    /// Get files with detected edits
    pub async fn list_edited_files(&self, project_id: Uuid) -> Result<Vec<TrackedFile>> {
        let rows: Vec<TrackedFileRow> = sqlx::query_as(
            r#"
            SELECT id, project_id, feature_id, file_path, content_hash,
                   generation_timestamp, last_verified_hash, last_verified_at, edit_detected
            FROM generated_files
            WHERE project_id = ? AND edit_detected = 1
            ORDER BY file_path ASC
            "#,
        )
        .bind(project_id.to_string())
        .fetch_all(&self.pool)
        .await
        .map_err(|e| Error::Other(format!("Database error: {}", e)))?;

        Ok(rows
            .into_iter()
            .map(|r| TrackedFile {
                id: Uuid::parse_str(&r.0).unwrap_or_default(),
                project_id: Uuid::parse_str(&r.1).unwrap_or_default(),
                feature_id: r.2.as_ref().and_then(|s| Uuid::parse_str(s).ok()),
                file_path: r.3,
                content_hash: r.4,
                generation_timestamp: r.5,
                last_verified_hash: r.6,
                last_verified_at: r.7,
                edit_detected: r.8 != 0,
            })
            .collect())
    }

    /// Update the verification status of a file
    pub async fn update_verification(
        &self,
        project_id: Uuid,
        file_path: &str,
        current_hash: &str,
        edit_detected: bool,
    ) -> Result<()> {
        sqlx::query(
            r#"
            UPDATE generated_files
            SET last_verified_hash = ?,
                last_verified_at = ?,
                edit_detected = ?
            WHERE project_id = ? AND file_path = ?
            "#,
        )
        .bind(current_hash)
        .bind(Utc::now())
        .bind(edit_detected)
        .bind(project_id.to_string())
        .bind(file_path)
        .execute(&self.pool)
        .await
        .map_err(|e| Error::Other(format!("Database error: {}", e)))?;

        Ok(())
    }

    /// Mark an edit as acknowledged (reset edit_detected flag)
    pub async fn acknowledge_edit(&self, project_id: Uuid, file_path: &str) -> Result<()> {
        sqlx::query(
            r#"
            UPDATE generated_files
            SET edit_detected = 0,
                content_hash = last_verified_hash
            WHERE project_id = ? AND file_path = ?
            "#,
        )
        .bind(project_id.to_string())
        .bind(file_path)
        .execute(&self.pool)
        .await
        .map_err(|e| Error::Other(format!("Database error: {}", e)))?;

        Ok(())
    }

    /// Remove a tracked file
    pub async fn untrack_file(&self, project_id: Uuid, file_path: &str) -> Result<bool> {
        let result = sqlx::query(
            r#"
            DELETE FROM generated_files
            WHERE project_id = ? AND file_path = ?
            "#,
        )
        .bind(project_id.to_string())
        .bind(file_path)
        .execute(&self.pool)
        .await
        .map_err(|e| Error::Other(format!("Database error: {}", e)))?;

        Ok(result.rows_affected() > 0)
    }

    /// Remove all tracked files for a project
    pub async fn untrack_all_for_project(&self, project_id: Uuid) -> Result<u64> {
        let result = sqlx::query(
            r#"
            DELETE FROM generated_files
            WHERE project_id = ?
            "#,
        )
        .bind(project_id.to_string())
        .execute(&self.pool)
        .await
        .map_err(|e| Error::Other(format!("Database error: {}", e)))?;

        Ok(result.rows_affected())
    }
}

/// Service for detecting user edits to generated code
pub struct EditDetectionService {
    repository: TrackedFileRepository,
    project_root: Option<std::path::PathBuf>,
}

impl EditDetectionService {
    /// Create a new edit detection service
    pub fn new(pool: SqlitePool) -> Self {
        Self {
            repository: TrackedFileRepository::new(pool),
            project_root: None,
        }
    }

    /// Create a service with a specific project root
    pub fn with_project_root(pool: SqlitePool, project_root: std::path::PathBuf) -> Self {
        Self {
            repository: TrackedFileRepository::new(pool),
            project_root: Some(project_root),
        }
    }

    /// Get a reference to the repository
    pub fn repository(&self) -> &TrackedFileRepository {
        &self.repository
    }

    /// Track a generated file
    ///
    /// Call this after successfully writing a generated file to disk.
    pub async fn track_generated_file(
        &self,
        project_id: Uuid,
        feature_id: Option<Uuid>,
        file_path: &str,
        content: &str,
    ) -> Result<TrackedFile> {
        let content_hash = compute_content_hash(content);

        let tracked = TrackedFile::new(
            project_id,
            feature_id,
            file_path.to_string(),
            content_hash,
        );

        self.repository.track_file(&tracked).await?;

        debug!(
            project_id = %project_id,
            file_path = %file_path,
            hash = %tracked.content_hash[..8],
            "Tracking generated file"
        );

        Ok(tracked)
    }

    /// Track multiple generated files
    pub async fn track_generated_files(
        &self,
        project_id: Uuid,
        feature_id: Option<Uuid>,
        files: &[(String, String)], // (path, content) pairs
    ) -> Result<Vec<TrackedFile>> {
        let mut tracked = Vec::new();

        for (path, content) in files {
            let file = self
                .track_generated_file(project_id, feature_id, path, content)
                .await?;
            tracked.push(file);
        }

        info!(
            project_id = %project_id,
            file_count = tracked.len(),
            "Tracked generated files"
        );

        Ok(tracked)
    }

    /// Check a single file for user edits
    pub async fn check_file(&self, project_id: Uuid, file_path: &str) -> Result<EditCheckResult> {
        let tracked = self.repository.get_by_path(project_id, file_path).await?;

        let Some(tracked) = tracked else {
            return Err(Error::NotFound(format!(
                "File not tracked: {}",
                file_path
            )));
        };

        let full_path = self.resolve_path(file_path);
        let (file_exists, current_hash) = match std::fs::read_to_string(&full_path) {
            Ok(content) => (true, Some(compute_content_hash(&content))),
            Err(e) if e.kind() == std::io::ErrorKind::NotFound => (false, None),
            Err(e) => {
                warn!(path = %full_path.display(), error = %e, "Failed to read file for edit check");
                (false, None)
            }
        };

        let edit_detected = match &current_hash {
            Some(hash) => hash != &tracked.content_hash,
            None => false, // File deleted is different from edited
        };

        // Update verification status in database
        if let Some(ref hash) = current_hash {
            self.repository
                .update_verification(project_id, file_path, hash, edit_detected)
                .await?;
        }

        Ok(EditCheckResult {
            file_path: file_path.to_string(),
            file_exists,
            edit_detected,
            original_hash: tracked.content_hash,
            current_hash,
        })
    }

    /// Check all tracked files for a project
    pub async fn check_all_files(&self, project_id: Uuid) -> Result<EditDetectionSummary> {
        let tracked_files = self.repository.list_by_project(project_id).await?;

        let mut summary = EditDetectionSummary {
            total_files: tracked_files.len(),
            ..Default::default()
        };

        for tracked in tracked_files {
            let full_path = self.resolve_path(&tracked.file_path);

            match std::fs::read_to_string(&full_path) {
                Ok(content) => {
                    let current_hash = compute_content_hash(&content);
                    let edit_detected = current_hash != tracked.content_hash;

                    // Update verification status
                    self.repository
                        .update_verification(
                            project_id,
                            &tracked.file_path,
                            &current_hash,
                            edit_detected,
                        )
                        .await?;

                    if edit_detected {
                        summary.modified_files.push(tracked.file_path);
                    } else {
                        summary.unchanged_files.push(tracked.file_path);
                    }
                }
                Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
                    summary.deleted_files.push(tracked.file_path);
                }
                Err(e) => {
                    warn!(
                        path = %full_path.display(),
                        error = %e,
                        "Failed to read file during edit check"
                    );
                    // Count as deleted since we can't verify
                    summary.deleted_files.push(tracked.file_path);
                }
            }
        }

        info!(
            project_id = %project_id,
            total = summary.total_files,
            modified = summary.modified_files.len(),
            deleted = summary.deleted_files.len(),
            "Completed edit detection check"
        );

        Ok(summary)
    }

    /// Check files for a specific feature
    pub async fn check_feature_files(&self, feature_id: Uuid) -> Result<EditDetectionSummary> {
        let tracked_files = self.repository.list_by_feature(feature_id).await?;

        let mut summary = EditDetectionSummary {
            total_files: tracked_files.len(),
            ..Default::default()
        };

        for tracked in tracked_files {
            let full_path = self.resolve_path(&tracked.file_path);

            match std::fs::read_to_string(&full_path) {
                Ok(content) => {
                    let current_hash = compute_content_hash(&content);
                    let edit_detected = current_hash != tracked.content_hash;

                    // Update verification status
                    self.repository
                        .update_verification(
                            tracked.project_id,
                            &tracked.file_path,
                            &current_hash,
                            edit_detected,
                        )
                        .await?;

                    if edit_detected {
                        summary.modified_files.push(tracked.file_path);
                    } else {
                        summary.unchanged_files.push(tracked.file_path);
                    }
                }
                Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
                    summary.deleted_files.push(tracked.file_path);
                }
                Err(e) => {
                    warn!(
                        path = %full_path.display(),
                        error = %e,
                        "Failed to read file during feature edit check"
                    );
                    summary.deleted_files.push(tracked.file_path);
                }
            }
        }

        Ok(summary)
    }

    /// Get list of files that have been edited
    pub async fn get_edited_files(&self, project_id: Uuid) -> Result<Vec<TrackedFile>> {
        self.repository.list_edited_files(project_id).await
    }

    /// Acknowledge user edits (accept them as the new baseline)
    ///
    /// This updates the stored hash to match the current file content,
    /// effectively accepting the user's changes as the new "generated" state.
    pub async fn acknowledge_edits(&self, project_id: Uuid, file_paths: &[String]) -> Result<usize> {
        let mut acknowledged = 0;

        for path in file_paths {
            self.repository.acknowledge_edit(project_id, path).await?;
            acknowledged += 1;
            debug!(path = %path, "Acknowledged user edit");
        }

        info!(
            project_id = %project_id,
            count = acknowledged,
            "Acknowledged user edits"
        );

        Ok(acknowledged)
    }

    /// Acknowledge all detected edits for a project
    pub async fn acknowledge_all_edits(&self, project_id: Uuid) -> Result<usize> {
        let edited = self.repository.list_edited_files(project_id).await?;
        let paths: Vec<String> = edited.into_iter().map(|f| f.file_path).collect();
        self.acknowledge_edits(project_id, &paths).await
    }

    /// Resolve a relative file path to an absolute path
    fn resolve_path(&self, file_path: &str) -> std::path::PathBuf {
        match &self.project_root {
            Some(root) => root.join(file_path),
            None => std::path::PathBuf::from(file_path),
        }
    }
}

/// Compute SHA-256 hash of content
pub fn compute_content_hash(content: &str) -> String {
    let mut hasher = Sha256::new();
    hasher.update(content.as_bytes());
    hex::encode(hasher.finalize())
}

/// Check if a path appears to be a generated file path
pub fn is_generated_path(path: &Path) -> bool {
    // Common patterns for generated code
    let path_str = path.to_string_lossy();

    // Check for common generated file indicators
    path_str.contains("generated")
        || path_str.contains("gen/")
        || path_str.contains(".gen.")
        || path_str.starts_with("src/")
        || path_str.contains("/src/")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage::Database;

    async fn create_test_db() -> SqlitePool {
        let db = Database::in_memory()
            .await
            .expect("Failed to create test database");
        db.pool().clone()
    }

    async fn create_test_project(pool: &SqlitePool) -> Uuid {
        let project_id = Uuid::new_v4();
        sqlx::query("INSERT INTO projects (id, name, framework) VALUES (?, ?, ?)")
            .bind(project_id.to_string())
            .bind("Test Project")
            .bind("rust")
            .execute(pool)
            .await
            .expect("Failed to insert test project");
        project_id
    }

    #[test]
    fn test_compute_content_hash() {
        let content = "fn main() { println!(\"Hello\"); }";
        let hash = compute_content_hash(content);

        // Hash should be consistent
        assert_eq!(hash, compute_content_hash(content));

        // Different content should have different hash
        let other_content = "fn main() { println!(\"World\"); }";
        assert_ne!(hash, compute_content_hash(other_content));

        // SHA-256 produces 64 hex characters
        assert_eq!(hash.len(), 64);
    }

    #[test]
    fn test_tracked_file_new() {
        let project_id = Uuid::new_v4();
        let file = TrackedFile::new(
            project_id,
            None,
            "src/main.rs".to_string(),
            "abc123".to_string(),
        );

        assert_eq!(file.project_id, project_id);
        assert_eq!(file.file_path, "src/main.rs");
        assert_eq!(file.content_hash, "abc123");
        assert!(!file.edit_detected);
        assert!(file.last_verified_hash.is_none());
    }

    #[test]
    fn test_edit_check_result_states() {
        // Unchanged file
        let result = EditCheckResult {
            file_path: "test.rs".to_string(),
            file_exists: true,
            edit_detected: false,
            original_hash: "hash1".to_string(),
            current_hash: Some("hash1".to_string()),
        };
        assert!(result.is_unchanged());
        assert!(!result.is_modified());
        assert!(!result.is_deleted());

        // Modified file
        let result = EditCheckResult {
            file_path: "test.rs".to_string(),
            file_exists: true,
            edit_detected: true,
            original_hash: "hash1".to_string(),
            current_hash: Some("hash2".to_string()),
        };
        assert!(result.is_modified());
        assert!(!result.is_unchanged());
        assert!(!result.is_deleted());

        // Deleted file
        let result = EditCheckResult {
            file_path: "test.rs".to_string(),
            file_exists: false,
            edit_detected: false,
            original_hash: "hash1".to_string(),
            current_hash: None,
        };
        assert!(result.is_deleted());
        assert!(!result.is_modified());
        assert!(!result.is_unchanged());
    }

    #[test]
    fn test_edit_detection_summary() {
        let summary = EditDetectionSummary {
            total_files: 5,
            modified_files: vec!["a.rs".to_string(), "b.rs".to_string()],
            deleted_files: vec!["c.rs".to_string()],
            unchanged_files: vec!["d.rs".to_string(), "e.rs".to_string()],
        };

        assert!(summary.has_changes());
        assert!(summary.summary().contains("5 files"));
        assert!(summary.summary().contains("2 modified"));
        assert!(summary.summary().contains("1 deleted"));
    }

    #[test]
    fn test_edit_detection_summary_no_changes() {
        let summary = EditDetectionSummary {
            total_files: 3,
            modified_files: vec![],
            deleted_files: vec![],
            unchanged_files: vec!["a.rs".to_string(), "b.rs".to_string(), "c.rs".to_string()],
        };

        assert!(!summary.has_changes());
    }

    #[tokio::test]
    async fn test_track_and_retrieve_file() {
        let pool = create_test_db().await;
        let project_id = create_test_project(&pool).await;
        let repo = TrackedFileRepository::new(pool);

        let file = TrackedFile::new(
            project_id,
            None,
            "src/lib.rs".to_string(),
            "test_hash_123".to_string(),
        );

        repo.track_file(&file).await.expect("Failed to track file");

        let retrieved = repo
            .get_by_path(project_id, "src/lib.rs")
            .await
            .expect("Failed to get file")
            .expect("File should exist");

        assert_eq!(retrieved.project_id, project_id);
        assert_eq!(retrieved.file_path, "src/lib.rs");
        assert_eq!(retrieved.content_hash, "test_hash_123");
        assert!(!retrieved.edit_detected);
    }

    #[tokio::test]
    async fn test_track_file_upsert() {
        let pool = create_test_db().await;
        let project_id = create_test_project(&pool).await;
        let repo = TrackedFileRepository::new(pool);

        // Track initial version
        let file1 = TrackedFile::new(
            project_id,
            None,
            "src/main.rs".to_string(),
            "hash_v1".to_string(),
        );
        repo.track_file(&file1).await.expect("Failed to track file");

        // Track updated version (same path)
        let file2 = TrackedFile::new(
            project_id,
            None,
            "src/main.rs".to_string(),
            "hash_v2".to_string(),
        );
        repo.track_file(&file2).await.expect("Failed to update file");

        // Should have the updated hash
        let retrieved = repo
            .get_by_path(project_id, "src/main.rs")
            .await
            .expect("Failed to get file")
            .expect("File should exist");

        assert_eq!(retrieved.content_hash, "hash_v2");
    }

    #[tokio::test]
    async fn test_list_by_project() {
        let pool = create_test_db().await;
        let project_id = create_test_project(&pool).await;
        let repo = TrackedFileRepository::new(pool);

        // Track multiple files
        for (i, path) in ["a.rs", "b.rs", "c.rs"].iter().enumerate() {
            let file = TrackedFile::new(
                project_id,
                None,
                path.to_string(),
                format!("hash_{}", i),
            );
            repo.track_file(&file).await.expect("Failed to track file");
        }

        let files = repo
            .list_by_project(project_id)
            .await
            .expect("Failed to list files");

        assert_eq!(files.len(), 3);
        // Should be sorted by path
        assert_eq!(files[0].file_path, "a.rs");
        assert_eq!(files[1].file_path, "b.rs");
        assert_eq!(files[2].file_path, "c.rs");
    }

    #[tokio::test]
    async fn test_update_verification() {
        let pool = create_test_db().await;
        let project_id = create_test_project(&pool).await;
        let repo = TrackedFileRepository::new(pool);

        let file = TrackedFile::new(
            project_id,
            None,
            "src/test.rs".to_string(),
            "original_hash".to_string(),
        );
        repo.track_file(&file).await.expect("Failed to track file");

        // Update verification with a different hash (edit detected)
        repo.update_verification(project_id, "src/test.rs", "modified_hash", true)
            .await
            .expect("Failed to update verification");

        let retrieved = repo
            .get_by_path(project_id, "src/test.rs")
            .await
            .expect("Failed to get file")
            .expect("File should exist");

        assert!(retrieved.edit_detected);
        assert_eq!(retrieved.last_verified_hash, Some("modified_hash".to_string()));
        assert!(retrieved.last_verified_at.is_some());
    }

    #[tokio::test]
    async fn test_list_edited_files() {
        let pool = create_test_db().await;
        let project_id = create_test_project(&pool).await;
        let repo = TrackedFileRepository::new(pool);

        // Track files
        for (i, path) in ["unchanged.rs", "edited.rs", "also_edited.rs"]
            .iter()
            .enumerate()
        {
            let file = TrackedFile::new(
                project_id,
                None,
                path.to_string(),
                format!("hash_{}", i),
            );
            repo.track_file(&file).await.expect("Failed to track file");
        }

        // Mark some as edited
        repo.update_verification(project_id, "edited.rs", "new_hash_1", true)
            .await
            .unwrap();
        repo.update_verification(project_id, "also_edited.rs", "new_hash_2", true)
            .await
            .unwrap();

        let edited = repo
            .list_edited_files(project_id)
            .await
            .expect("Failed to list edited files");

        assert_eq!(edited.len(), 2);
        assert!(edited.iter().any(|f| f.file_path == "edited.rs"));
        assert!(edited.iter().any(|f| f.file_path == "also_edited.rs"));
    }

    #[tokio::test]
    async fn test_acknowledge_edit() {
        let pool = create_test_db().await;
        let project_id = create_test_project(&pool).await;
        let repo = TrackedFileRepository::new(pool);

        let file = TrackedFile::new(
            project_id,
            None,
            "src/edited.rs".to_string(),
            "original_hash".to_string(),
        );
        repo.track_file(&file).await.expect("Failed to track file");

        // Detect an edit
        repo.update_verification(project_id, "src/edited.rs", "user_modified_hash", true)
            .await
            .unwrap();

        // Acknowledge the edit
        repo.acknowledge_edit(project_id, "src/edited.rs")
            .await
            .expect("Failed to acknowledge edit");

        let retrieved = repo
            .get_by_path(project_id, "src/edited.rs")
            .await
            .expect("Failed to get file")
            .expect("File should exist");

        // Edit should no longer be flagged
        assert!(!retrieved.edit_detected);
        // Hash should be updated to the user's version
        assert_eq!(retrieved.content_hash, "user_modified_hash");
    }

    #[tokio::test]
    async fn test_untrack_file() {
        let pool = create_test_db().await;
        let project_id = create_test_project(&pool).await;
        let repo = TrackedFileRepository::new(pool);

        let file = TrackedFile::new(
            project_id,
            None,
            "src/temporary.rs".to_string(),
            "hash".to_string(),
        );
        repo.track_file(&file).await.expect("Failed to track file");

        let deleted = repo
            .untrack_file(project_id, "src/temporary.rs")
            .await
            .expect("Failed to untrack file");

        assert!(deleted);

        let retrieved = repo
            .get_by_path(project_id, "src/temporary.rs")
            .await
            .expect("Failed to get file");

        assert!(retrieved.is_none());
    }

    #[test]
    fn test_is_generated_path() {
        assert!(is_generated_path(Path::new("src/main.rs")));
        assert!(is_generated_path(Path::new("generated/output.rs")));
        assert!(is_generated_path(Path::new("path/gen/file.rs")));
        assert!(is_generated_path(Path::new("file.gen.rs")));
        assert!(!is_generated_path(Path::new("readme.md")));
    }
}
